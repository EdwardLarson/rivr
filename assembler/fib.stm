INPUT(NUMBER), $!3 -> $0;				N = input from (stdin)
LT(NUMBER), $0, 2 -> $1;				N < 2
BRANCH, $1, :FIB_ARRAY_ALLOC;			if N >= 2: goto FIB_ARRAY_ALLOC
EQ(NUMBER), $0, $!1 -> $1
BRANCH, $1, :RESULT_IS_ZERO
MOVE, $!1 -> $32;						result = 1
JUMP, :RETURN;							goto RETURN

:RESULT_IS_ZERO
MOVE, $!0 -> $32;						result = 0
JUMP, :RETURN;							goto RETURN

:FIB_ARRAY_ALLOC
INCR, $0 -> $1
M_ALLOC, $1 -> $1;						arr = new array[N + 1]
M_STORE, $1, $!1, $!0;					arr[0] = 1
M_STORE, $1, $!1, $!1;					arr[1] = 1
MOVE, 2 -> $2;							i = 2

:FIB_LOOP
DECR, $2 -> $3;							x = i - 1
DECR, $3 -> $4;							y = x - 1 = i - 2
M_LOAD, $1, $3 -> $3;					prev1 = arr[x]
M_LOAD, $1, $4 -> $4;					prev2 = arr[y]
ADD(NUMBER), $3, $4 -> $3;				next = prev1 + prev2
M_STORE, $1, $3, $2;					arr[i] = next
INCR, $2 -> $2;							i++
EQ(NUMBER), $2, $0 -> $3;				is_eq = i == N
GT(NUMBER), $2, $0 -> $4;				is_gt = i > N
OR, $3, $4 -> $3;						is_gte = is_eq || is_gt
BRANCH, $3, :FIB_LOOP;					if !is_gte: goto FIB_LOOP
DECR, $2 -> $2;							i--
M_LOAD, $1, $2 -> $32;					result = array[i]

:RETURN
OUTPUT(NUMBER), $!2, $32;				print result
HALT