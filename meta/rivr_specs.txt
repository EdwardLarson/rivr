// Primitive types:
// int = integers
// rat = rationals (double-precision floating point numbers)
// str = immutable strings (characters are not a separate type, being instead strings of length 1)
// f() = function, with argument typed inside parentheses and returns after an arrow (e.g. f(int)->int or f()->(int, int) )
// {} = object type, with one or more classes inside the brackets; objects are maps, mapping string keys to primitive values

// Definition of an atom. Atoms are immutable.
myvar :: 5

// Definition of a function atom. Most functions are atoms.
// Because of this, the same name cannot be used for functions with different signatures; they are different types
foo :: f(int z, str word) -> int:
    // size returns the number of bytes a primitive takes up
    return z * size(word)
    
// Declaration of a variable, implicitly typed as a string
globalVar := "I am a string!"

// Declaration of a variable, implicitly typed as a function
globalFunc := f(int x, int y)-> (int, int): return (x*y), (x+y)

// Reassignment of a variable
globalFunc = f(int x, int y)-> (int, int): return (x/y), (x-y)

// Declaration of a variable to an explicit type with no assigned values
globalVar2 := str

// Declaration of a function variable without an assigned values
globalFunc2 := f(int x)->int

class MyClass:
    x := int
    y := int
    @public
    n :: 10
    
    @public
    get_x :: 
        f()->int: return .x
    @public
    get_y :: 
        f()->int: return .y
        
    @public
    MyClass ::
        f(int x, int y):
            .x = x
            .y = y
    

class MyCompositeClass is {MyClass, Component1, Component2}:
    z := int
    
    @public
    MyCompositeClass ::
    
    
    
    
    
    
    
    
    
    
    
    
    